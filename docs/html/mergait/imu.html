<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>mergait.imu API documentation</title>
<meta name="description" content="Methods that extract features from imu data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mergait.imu</code></h1>
</header>
<section id="section-intro">
<p>Methods that extract features from imu data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Methods that extract features from imu data.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
from mergait.stats import *

import logging

logging.basicConfig(level=logging.DEBUG)
log = logging.getLogger(&#34;MerGait&#34;)


def gait_features_from_vertical_acceleration(
    timestamps, a_vert, contact_time_range=[50, 200], step_time_range=[200, 1000]
):
    &#34;&#34;&#34;
    Extract gait features from the vertical acceleration of a IMU alone.
    It detects initial contact of the foot on the ground and the final contact point and uses
    this to compute step and stride variability.

    Note: This is a rather simplified algorithm based on peak finding. The advantage is that it gives
    rather robust results independent of the sensor position on the body. The disadvantage is that the
    detected contact times may not be an exact value that you could get with foodpod sensors, however the values
    can be used to obtain more relative symmetry information.

    Parameters
    ----------
    timestamps : list
        List of timestamps [ns]
    a_vert : list
        List with the same length as the timestamps with the vertical acceleration component
    df_phone_activity : pandas.DataFrame
        DataFrame containing the phone activity monitor data
    contact_time_range : list
        A 2-list specifying the minimum and maximum expected contact time of a foot [ms]
    step_time_range : list
        A 2-list specifying the minimum and maximum expected duration of a step [ms]

    Returns
    -------
    pandas.DataFrame
        Index:
            RangeIndex
        Columns:
            Name: t, dtype: datetime64[ns]
                Timestamp of the initial foot impact
            Name: contact_time, dtype: float64
                Time between final contact and initial contact
            Name: step_duration, dtype: float64
                Time between initial contact and the initial contact of the opposite foot
            Name: cadence, dtype: float64
                Steps per minute, derived from step_duration
            Name: stride_duration, dtype: float64
                Time between two initial contacts of the same foot
            Name: flight_ratio, dtype: float64
                The ratio of a step that both feet are in the air
            Name: impact, dtype: float64
                The peak acceleration at contact
    list
        A list of initial contact times
    list
        A list of final contact times

    &#34;&#34;&#34;
    log.debug(
        &#34;[ Extracting gait features from the vertical acceleration of a motion sensor&#34;
    )

    from scipy.signal import find_peaks

    fc_peaks, _ = find_peaks(a_vert, prominence=1.5)
    ic_peaks, _ = find_peaks(-a_vert, prominence=1.5)

    log.debug(&#34;Finding initial and final contact peaks&#34;)
    ic_times_ns = timestamps.iloc[ic_peaks]
    fc_times_ns = timestamps.iloc[fc_peaks]
    log.debug(&#34;Found {} IC and {} FC peaks&#34;.format(len(ic_times_ns), len(fc_times_ns)))

    ic_times = pd.to_datetime(ic_times_ns)
    fc_times = pd.to_datetime(fc_times_ns)

    min_contact_time = pd.Timedelta(contact_time_range[0], &#34;ms&#34;)
    max_contact_time = pd.Timedelta(contact_time_range[1], &#34;ms&#34;)
    min_step_time = pd.Timedelta(step_time_range[0], &#34;ms&#34;)
    max_step_time = pd.Timedelta(step_time_range[1], &#34;ms&#34;)

    ds_ic = pd.DataFrame(
        {
            &#34;t&#34;: ic_times,
            &#34;t_contact_min&#34;: ic_times + min_contact_time,
            &#34;t_step_min&#34;: ic_times + min_step_time,
            &#34;t_ic&#34;: ic_times_ns,
            &#34;impact&#34;: -a_vert.iloc[ic_peaks],
        }
    ).reset_index(drop=True)
    ds_fc = pd.DataFrame({&#34;t&#34;: fc_times, &#34;t_fc&#34;: fc_times_ns}).reset_index(drop=True)

    log.debug(&#34;Collecting contact pairs for feature extraction&#34;)
    # collect intitial-final contact pair
    df = pd.merge_asof(
        ds_ic,
        ds_fc,
        left_on=&#34;t_contact_min&#34;,
        right_on=&#34;t&#34;,
        direction=&#34;forward&#34;,
        suffixes=[None, &#34;_fcm&#34;],
        tolerance=max_contact_time - min_contact_time,
    )
    df[&#34;contact_time&#34;] = (df[&#34;t_fc&#34;] - df[&#34;t_ic&#34;]) / 1e6
    df.drop([&#34;t_fc&#34;, &#34;t_fcm&#34;], axis=1, inplace=True)

    # collect initial contact one foot and opposite foot
    df = pd.merge_asof(
        df,
        ds_ic[[&#34;t&#34;, &#34;t_ic&#34;]],
        left_on=&#34;t_step_min&#34;,
        right_on=&#34;t&#34;,
        suffixes=[None, &#34;_opp&#34;],
        direction=&#34;forward&#34;,
        tolerance=max_step_time - min_step_time,
    )
    df[&#34;step_duration&#34;] = (df[&#34;t_ic_opp&#34;] - df[&#34;t_ic&#34;]) / 1e6
    df[&#34;cadence&#34;] = 60 / df[&#34;step_duration&#34;]

    # filter out invalid steps due to double ic/fc detections
    df = df[
        df[&#34;t&#34;].shift(-1) - df[&#34;t&#34;] &gt; min_step_time
    ]  # double ic&#39;s lead to invalid step times
    df = df[
        df[&#34;step_duration&#34;] &gt; df[&#34;contact_time&#34;]
    ]  # contact time cannot be longer than step time

    df[&#34;stride_duration&#34;] = pd.to_numeric(df[&#34;t&#34;].shift(-2) - df[&#34;t&#34;]) / 1e6
    df = df[df[&#34;stride_duration&#34;] &gt; 0]  # stride duration must be positive
    df = df[
        df[&#34;t&#34;].shift(-2) - df[&#34;t&#34;] &lt; 2 * max_step_time
    ]  # also enforce maximum stride time

    df[&#34;flight_ratio&#34;] = (df[&#34;step_duration&#34;] - df[&#34;contact_time&#34;]) / df[
        &#34;step_duration&#34;
    ]

    # drop extra columns and do clean up
    df.drop(
        [&#34;t_contact_min&#34;, &#34;t_step_min&#34;, &#34;t_ic&#34;, &#34;t_opp&#34;, &#34;t_ic_opp&#34;],
        axis=1,
        inplace=True,
    )
    df.reset_index(drop=True, inplace=True)

    log.debug(&#34;] Done, returning {} gait cycles&#34;.format(len(df)))

    return df, ic_times, fc_times


def gait_symmety_index_from_acceleration(
    ax, ay, az, maxlag=150, deadlag=50, sample_rate=100
):
    &#34;&#34;&#34;
    Determine the gait symmetry index (GSI) from the 3-axes acceleration.
    GSI computation from: &#34;Gait Symmetry Assessment with a Low Back 3D
    Accelerometer in Post-Stroke Patients&#34; (Zhang, 2018)

    Parameters
    ----------
    ax, ay, az : list
        List of the three axes of acceleration, direction is not important but should not change
        within a single computation
    maxlag : float
        Maximum lag to compute the autocorrelation and expect a peak. Units is in samples.
    deadlag : float
        Minimum lag to compute the autocorrelation and expect a peak. Units is in samples.
    sample_rate : float
        Expected sampling rate of the data

    Returns
    -------
    float
        The complement of the gsi, meaning 0 = symmetric, 1 = asymmetric
    float
        Lag corresponding to the stride duration (in seconds)
    &#34;&#34;&#34;

    if len(ax) &lt;= deadlag:
        return np.nan, np.nan

    # design 2nd order lp-butterworth filter
    from scipy import signal

    sos = signal.butter(2, 10, &#34;low&#34;, fs=sample_rate, output=&#34;sos&#34;)
    fax = signal.sosfilt(sos, ax)
    fay = signal.sosfilt(sos, ay)
    faz = signal.sosfilt(sos, az)

    # use the unbiased autocorrelation (does not taper) to get unbiased value
    ARx = autocorrelate(fax)[:maxlag]
    ARy = autocorrelate(fay)[:maxlag]
    ARz = autocorrelate(faz)[:maxlag]
    Cstep = np.sqrt(ARx ** 2 + ARy ** 2 + ARz ** 2)

    # use biased autocorrelation (tapers off) to ensure getting the first peak
    ARx = autocorrelate(fax, unbiased=False)[:maxlag]
    ARy = autocorrelate(fay, unbiased=False)[:maxlag]
    ARz = autocorrelate(faz, unbiased=False)[:maxlag]

    ARx[ARx &lt; 0] = 0
    ARy[ARy &lt; 0] = 0
    ARz[ARz &lt; 0] = 0
    Cstride = ARx + ARy + ARz
    Tstride = deadlag + np.argmax(Cstride[deadlag:])
    GSI = Cstep[Tstride // 2] / np.sqrt(3)

    stride_duration = Tstride / sample_rate

    return 1 - GSI, stride_duration</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mergait.imu.gait_features_from_vertical_acceleration"><code class="name flex">
<span>def <span class="ident">gait_features_from_vertical_acceleration</span></span>(<span>timestamps, a_vert, contact_time_range=[50, 200], step_time_range=[200, 1000])</span>
</code></dt>
<dd>
<div class="desc"><p>Extract gait features from the vertical acceleration of a IMU alone.
It detects initial contact of the foot on the ground and the final contact point and uses
this to compute step and stride variability.</p>
<p>Note: This is a rather simplified algorithm based on peak finding. The advantage is that it gives
rather robust results independent of the sensor position on the body. The disadvantage is that the
detected contact times may not be an exact value that you could get with foodpod sensors, however the values
can be used to obtain more relative symmetry information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>list</code></dt>
<dd>List of timestamps [ns]</dd>
<dt><strong><code>a_vert</code></strong> :&ensp;<code>list</code></dt>
<dd>List with the same length as the timestamps with the vertical acceleration component</dd>
<dt><strong><code>df_phone_activity</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>DataFrame containing the phone activity monitor data</dd>
<dt><strong><code>contact_time_range</code></strong> :&ensp;<code>list</code></dt>
<dd>A 2-list specifying the minimum and maximum expected contact time of a foot [ms]</dd>
<dt><strong><code>step_time_range</code></strong> :&ensp;<code>list</code></dt>
<dd>A 2-list specifying the minimum and maximum expected duration of a step [ms]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>Index:
RangeIndex
Columns:
Name: t, dtype: datetime64[ns]
Timestamp of the initial foot impact
Name: contact_time, dtype: float64
Time between final contact and initial contact
Name: step_duration, dtype: float64
Time between initial contact and the initial contact of the opposite foot
Name: cadence, dtype: float64
Steps per minute, derived from step_duration
Name: stride_duration, dtype: float64
Time between two initial contacts of the same foot
Name: flight_ratio, dtype: float64
The ratio of a step that both feet are in the air
Name: impact, dtype: float64
The peak acceleration at contact</dd>
<dt><code>list</code></dt>
<dd>A list of initial contact times</dd>
<dt><code>list</code></dt>
<dd>A list of final contact times</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gait_features_from_vertical_acceleration(
    timestamps, a_vert, contact_time_range=[50, 200], step_time_range=[200, 1000]
):
    &#34;&#34;&#34;
    Extract gait features from the vertical acceleration of a IMU alone.
    It detects initial contact of the foot on the ground and the final contact point and uses
    this to compute step and stride variability.

    Note: This is a rather simplified algorithm based on peak finding. The advantage is that it gives
    rather robust results independent of the sensor position on the body. The disadvantage is that the
    detected contact times may not be an exact value that you could get with foodpod sensors, however the values
    can be used to obtain more relative symmetry information.

    Parameters
    ----------
    timestamps : list
        List of timestamps [ns]
    a_vert : list
        List with the same length as the timestamps with the vertical acceleration component
    df_phone_activity : pandas.DataFrame
        DataFrame containing the phone activity monitor data
    contact_time_range : list
        A 2-list specifying the minimum and maximum expected contact time of a foot [ms]
    step_time_range : list
        A 2-list specifying the minimum and maximum expected duration of a step [ms]

    Returns
    -------
    pandas.DataFrame
        Index:
            RangeIndex
        Columns:
            Name: t, dtype: datetime64[ns]
                Timestamp of the initial foot impact
            Name: contact_time, dtype: float64
                Time between final contact and initial contact
            Name: step_duration, dtype: float64
                Time between initial contact and the initial contact of the opposite foot
            Name: cadence, dtype: float64
                Steps per minute, derived from step_duration
            Name: stride_duration, dtype: float64
                Time between two initial contacts of the same foot
            Name: flight_ratio, dtype: float64
                The ratio of a step that both feet are in the air
            Name: impact, dtype: float64
                The peak acceleration at contact
    list
        A list of initial contact times
    list
        A list of final contact times

    &#34;&#34;&#34;
    log.debug(
        &#34;[ Extracting gait features from the vertical acceleration of a motion sensor&#34;
    )

    from scipy.signal import find_peaks

    fc_peaks, _ = find_peaks(a_vert, prominence=1.5)
    ic_peaks, _ = find_peaks(-a_vert, prominence=1.5)

    log.debug(&#34;Finding initial and final contact peaks&#34;)
    ic_times_ns = timestamps.iloc[ic_peaks]
    fc_times_ns = timestamps.iloc[fc_peaks]
    log.debug(&#34;Found {} IC and {} FC peaks&#34;.format(len(ic_times_ns), len(fc_times_ns)))

    ic_times = pd.to_datetime(ic_times_ns)
    fc_times = pd.to_datetime(fc_times_ns)

    min_contact_time = pd.Timedelta(contact_time_range[0], &#34;ms&#34;)
    max_contact_time = pd.Timedelta(contact_time_range[1], &#34;ms&#34;)
    min_step_time = pd.Timedelta(step_time_range[0], &#34;ms&#34;)
    max_step_time = pd.Timedelta(step_time_range[1], &#34;ms&#34;)

    ds_ic = pd.DataFrame(
        {
            &#34;t&#34;: ic_times,
            &#34;t_contact_min&#34;: ic_times + min_contact_time,
            &#34;t_step_min&#34;: ic_times + min_step_time,
            &#34;t_ic&#34;: ic_times_ns,
            &#34;impact&#34;: -a_vert.iloc[ic_peaks],
        }
    ).reset_index(drop=True)
    ds_fc = pd.DataFrame({&#34;t&#34;: fc_times, &#34;t_fc&#34;: fc_times_ns}).reset_index(drop=True)

    log.debug(&#34;Collecting contact pairs for feature extraction&#34;)
    # collect intitial-final contact pair
    df = pd.merge_asof(
        ds_ic,
        ds_fc,
        left_on=&#34;t_contact_min&#34;,
        right_on=&#34;t&#34;,
        direction=&#34;forward&#34;,
        suffixes=[None, &#34;_fcm&#34;],
        tolerance=max_contact_time - min_contact_time,
    )
    df[&#34;contact_time&#34;] = (df[&#34;t_fc&#34;] - df[&#34;t_ic&#34;]) / 1e6
    df.drop([&#34;t_fc&#34;, &#34;t_fcm&#34;], axis=1, inplace=True)

    # collect initial contact one foot and opposite foot
    df = pd.merge_asof(
        df,
        ds_ic[[&#34;t&#34;, &#34;t_ic&#34;]],
        left_on=&#34;t_step_min&#34;,
        right_on=&#34;t&#34;,
        suffixes=[None, &#34;_opp&#34;],
        direction=&#34;forward&#34;,
        tolerance=max_step_time - min_step_time,
    )
    df[&#34;step_duration&#34;] = (df[&#34;t_ic_opp&#34;] - df[&#34;t_ic&#34;]) / 1e6
    df[&#34;cadence&#34;] = 60 / df[&#34;step_duration&#34;]

    # filter out invalid steps due to double ic/fc detections
    df = df[
        df[&#34;t&#34;].shift(-1) - df[&#34;t&#34;] &gt; min_step_time
    ]  # double ic&#39;s lead to invalid step times
    df = df[
        df[&#34;step_duration&#34;] &gt; df[&#34;contact_time&#34;]
    ]  # contact time cannot be longer than step time

    df[&#34;stride_duration&#34;] = pd.to_numeric(df[&#34;t&#34;].shift(-2) - df[&#34;t&#34;]) / 1e6
    df = df[df[&#34;stride_duration&#34;] &gt; 0]  # stride duration must be positive
    df = df[
        df[&#34;t&#34;].shift(-2) - df[&#34;t&#34;] &lt; 2 * max_step_time
    ]  # also enforce maximum stride time

    df[&#34;flight_ratio&#34;] = (df[&#34;step_duration&#34;] - df[&#34;contact_time&#34;]) / df[
        &#34;step_duration&#34;
    ]

    # drop extra columns and do clean up
    df.drop(
        [&#34;t_contact_min&#34;, &#34;t_step_min&#34;, &#34;t_ic&#34;, &#34;t_opp&#34;, &#34;t_ic_opp&#34;],
        axis=1,
        inplace=True,
    )
    df.reset_index(drop=True, inplace=True)

    log.debug(&#34;] Done, returning {} gait cycles&#34;.format(len(df)))

    return df, ic_times, fc_times</code></pre>
</details>
</dd>
<dt id="mergait.imu.gait_symmety_index_from_acceleration"><code class="name flex">
<span>def <span class="ident">gait_symmety_index_from_acceleration</span></span>(<span>ax, ay, az, maxlag=150, deadlag=50, sample_rate=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the gait symmetry index (GSI) from the 3-axes acceleration.
GSI computation from: "Gait Symmetry Assessment with a Low Back 3D
Accelerometer in Post-Stroke Patients" (Zhang, 2018)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong>, <strong><code>ay</code></strong>, <strong><code>az</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the three axes of acceleration, direction is not important but should not change
within a single computation</dd>
<dt><strong><code>maxlag</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum lag to compute the autocorrelation and expect a peak. Units is in samples.</dd>
<dt><strong><code>deadlag</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum lag to compute the autocorrelation and expect a peak. Units is in samples.</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Expected sampling rate of the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The complement of the gsi, meaning 0 = symmetric, 1 = asymmetric</dd>
<dt><code>float</code></dt>
<dd>Lag corresponding to the stride duration (in seconds)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gait_symmety_index_from_acceleration(
    ax, ay, az, maxlag=150, deadlag=50, sample_rate=100
):
    &#34;&#34;&#34;
    Determine the gait symmetry index (GSI) from the 3-axes acceleration.
    GSI computation from: &#34;Gait Symmetry Assessment with a Low Back 3D
    Accelerometer in Post-Stroke Patients&#34; (Zhang, 2018)

    Parameters
    ----------
    ax, ay, az : list
        List of the three axes of acceleration, direction is not important but should not change
        within a single computation
    maxlag : float
        Maximum lag to compute the autocorrelation and expect a peak. Units is in samples.
    deadlag : float
        Minimum lag to compute the autocorrelation and expect a peak. Units is in samples.
    sample_rate : float
        Expected sampling rate of the data

    Returns
    -------
    float
        The complement of the gsi, meaning 0 = symmetric, 1 = asymmetric
    float
        Lag corresponding to the stride duration (in seconds)
    &#34;&#34;&#34;

    if len(ax) &lt;= deadlag:
        return np.nan, np.nan

    # design 2nd order lp-butterworth filter
    from scipy import signal

    sos = signal.butter(2, 10, &#34;low&#34;, fs=sample_rate, output=&#34;sos&#34;)
    fax = signal.sosfilt(sos, ax)
    fay = signal.sosfilt(sos, ay)
    faz = signal.sosfilt(sos, az)

    # use the unbiased autocorrelation (does not taper) to get unbiased value
    ARx = autocorrelate(fax)[:maxlag]
    ARy = autocorrelate(fay)[:maxlag]
    ARz = autocorrelate(faz)[:maxlag]
    Cstep = np.sqrt(ARx ** 2 + ARy ** 2 + ARz ** 2)

    # use biased autocorrelation (tapers off) to ensure getting the first peak
    ARx = autocorrelate(fax, unbiased=False)[:maxlag]
    ARy = autocorrelate(fay, unbiased=False)[:maxlag]
    ARz = autocorrelate(faz, unbiased=False)[:maxlag]

    ARx[ARx &lt; 0] = 0
    ARy[ARy &lt; 0] = 0
    ARz[ARz &lt; 0] = 0
    Cstride = ARx + ARy + ARz
    Tstride = deadlag + np.argmax(Cstride[deadlag:])
    GSI = Cstep[Tstride // 2] / np.sqrt(3)

    stride_duration = Tstride / sample_rate

    return 1 - GSI, stride_duration</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mergait" href="index.html">mergait</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mergait.imu.gait_features_from_vertical_acceleration" href="#mergait.imu.gait_features_from_vertical_acceleration">gait_features_from_vertical_acceleration</a></code></li>
<li><code><a title="mergait.imu.gait_symmety_index_from_acceleration" href="#mergait.imu.gait_symmety_index_from_acceleration">gait_symmety_index_from_acceleration</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>